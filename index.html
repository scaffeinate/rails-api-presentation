<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=1024" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Writing an API using Rails</title>
  <link href="css/impress-demo.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="css/custom.css" />
  <link rel="stylesheet" type="text/css" href="css/prism.css" />
</head>
<body>
  <div id="impress">
    <div class="step slide" data-x="0" data-y="-1500">
      <h1 class="center-content"><b>Writing an API for your Rails App</b></h1>
    </div>
    <div class="step slide" data-x="1000" data-y="-1500">
      <div class="center-content">
        <h2><b>The Problem</b></h2>
        <label>The need to write an API for your Rails app</label>
      </div>
    </div>
    <div class="step slide" data-x="2000" data-y="-2500">
      <h1 class="text-center"><b>The Rise of client side JavaScript <br><br>Frameworks</b></h1>
      <br>
      <img src="images/ember.png" alt="Ember" style="width: 200px;" />
      <img src="images/backbone.png" alt="Backbone" style="width: 200px; float: right;" /><br><br>
      <div class="text-center"><img src="images/angular.png" alt="Angular" style="width: 300px;" /></div>
    </div>
    <div class="step slide" data-x="3000" data-y="-2500">
      <h1 class="text-center"><b>Writing a REST API</b></h1><br><br>
      <h6>Rails already follows a RESTful architecture. To generate a RESTful json API we can add format.json to our respond_to block.</h6><br>
      <pre><code class="language-ruby">
        class PostsController < ApplicationController
          def index
            @posts = Post.all
            respond_to do |format|
              format.html
              format.json { render json: @posts }
            end
          end
        end
      </code></pre> 
    </div>
    <div class="step slide" data-x="4000" data-y="-2500">
      <div class="text-center">
        <label>Visiting <b>/posts.json</b> will render the following json.</label>
      </div>
      <pre style="line-height: 30px;"><code class="language-javascript">
        [
          {
            "id":1,
            "name":"Sample",
            "post_url":"www.google.com",
            "user_id":1,
            "url":"http://localhost:3000/posts/1.json"
          },
          {
            "id":2,
            "name":"Fb",
            "post_url":"www.facebook.com",
            "user_id":1,
            "url":"http://localhost:3000/posts/2.json"
        }
      ]
  </code></pre>
    </div>
    <div class="step slide" data-x="5000" data-y="-2500">
      <div class="center-content">
        <h1><b>That's it. JSON API Ready?</b></h1>
        <br><br><h1><b>Not Yet.</b></h1>
      </div>
    </div>
    <div class="step slide" data-x="6000" data-y="100" style="background-color: ">
      <div class="center-content">
        <h1><b>API Versioning</b></h1>
        <br><br>
        <h1><b>Why?</b></h1>
      </div>
    </div>
    <div class="step slide" data-x="7000" data-y="100">
      <label>If you are writing a consistent API which will be consumed by multiple clients then  it is the best practise to separate out the API under a namespace.</label><br><br>
      <label>API versioning lets your API to be backwards compatible.</label>
      <br><br><br>
      <h6><a href="http://stackoverflow.com/questions/389169/best-practices-for-api-versioning">http://stackoverflow.com/questions/389169/best-practices-for-api-versioning</a></h6>
    </div>
    <div class="step slide" data-x="8000" data-y="100">
      <br><br><label>Move your API under a namespace <b>:api</b> and the <b>:version</b> in your <b>routes.rb</b></label>
      <br><br>
      <pre>
        <code class="language-ruby">
          Rails.application.routes.draw do
            namespace :api do
              namespace :v1 do
                resources :users
                resources :posts
                resources :videos
                resources :sessions
                resources :tags
                resources :favorites
              end
            end
          end
        </code>
      </pre>
    </div>
    <div class="step slide" data-x="9000" data-y="100">
      <label>So if you want to introduce a new API version with new features the all you need to do is generate it under /:api/:new_version. </label>
    <label>(Something like myawesomedomain/api/v2)</label>
    <br><label>This ensures the changes are applied only to the current version without affecting the old API.</label>
    <br>
    <pre>
        <code class="language-ruby">
          Rails.application.routes.draw do
            namespace :api do
              namespace :v2 do
                resources :users, only: [:create, :show]
                resources :posts, except: :destroy
                resources :videos
                resources :sessions
                resources :tags
                resources :favorites
              end
            end
          end
        </code>
      </pre>
    </div>
    <div class="step slide" data-x="10000" data-y="100">
      <div class="text-center"><label>app/controllers/api/v1/posts_controller.rb</label></div>
      <pre>
        <code class="language-ruby">
          class Api::V1::PostsController < ApplicationController
            respond_to :json
            def index
              @posts = Post.all
              render json: @posts
            end
          end
        </code>
      </pre>
      <div class="text-center"><label>app/controllers/api/v2/posts_controller.rb</label></div>
      <pre>
        <code class="language-ruby">
          class Api::V2::PostsController < ApplicationController  
            respond_to :json
            def index
              @posts = Post.where('created_at >= ?', custom_time)
              render json: @posts
            end
          end 
        </code>
      </pre>
    </div>
    <div class="step slide" data-x="11000" data-y="100">
      <br><h2 class="text-center"><b>Default to JSON</b></h2>
      <br><label>You can make the API controllers default to json by adding format in the routes file.
      Visiting api/v1/posts will produce the json instead of html content.</label><br><br>
      <pre>
        <code class="language-ruby">
        Rails.application.routes.draw do
          namespace :api, defaults: {format: :json} do
            namespace :v1 do
              resources :users
              resources :posts
              resources :videos
              resources :sessions
              resources :tags
              resources :favorites
            end
          end
        end</code>
      </pre>
    </div>
    <div class="step slide" data-x="12000" data-y="100">
      <h2 class="text-center"><b>API Controller</b></h2>
      <br><label>Additionally you can generate an API Controller that inherits from ApplicationController.
      Then you can check the API specific Logic like Http Header and Token verification without affecting the functionality of the App.</label><br>
      <pre>
        <code class="language-ruby">
          class Api::V1::ApiController < ApplicationController
            #Add Api Specific methods and validation
          end 
        </code>
      </pre>
      <pre>
        <code class="language-ruby">
          class Api::V1::PostsController < Api::V1::ApiController
            def index
              @posts = Post.all
              render json: @posts
            end
          end 
        </code>
      </pre>
      <label class="text-center" style="display: block;"><a href="http://andrewberls.com/blog/post/api-versioning-with-rails-4">http://andrewberls.com/blog/post/api-versioning-with-rails-4</a></label>
    </div>
    <div class="step slide" data-x="12000" data-y="1000">
      <div class="center-content">
        <h1><b>Structuring JSON</b></h1>
      </div>
    </div>
    <div class="step slide" data-x="13000" data-y="1000">
      <pre>
        <code class="language-javascript">
        {
          "id": 1,
          "name": "Sample",
          "post_url": "www.google.com",
          "user_id": 1,
          "created_at": "2014-05-22T14:07:20.235Z",
          "updated_at": "2014-05-22T14:07:20.235Z"
        }</code>
      </pre>
      <pre>
        <code class="language-javascript">
        {
          "id": 1,
          "post_name": "Sample",
          "post_url": "www.google.com",
          "user_id": 1,
          "tag_ids": [1, 2, 3]
        }</code>
      </pre>
    </div>
    <div class="slide step" data-x="14000" data-y="1000">
      <label class="center-content" style="display: block;">Rails serializes the object passed into the required format. What if you want to customise th JSON output? Like Remove the root element, Add custom attributes or Adding has_many relations? How do you acheive this?</label>
    </div>
    <div class="slide step" data-x="15000" data-y="100">
      <h1 class="text-center"><b>JBuilder</b></h1><br>
      <br><label>Jbuilder gives you a simple DSL for declaring JSON structures that beats massaging giant hash structures.</label><br>
      <label class="text-center">controllers/api/v1/posts_controller.rb</label>
      <pre>
        <code class="language-ruby">
        class Api::V1::PostsController < Api::V1::ApiController
          def index
            @posts = Post.all
          end

          def show
            @post = Post.find(params[:id])
          end
        end</code>
      </pre>
    </div>
    <div class="step slide" data-x="16000" data-y="100">
      <br><label class="text-center">views/api/v1/posts/index.json.jbuilder</label>
      <pre>
        <code class="language-ruby">
          json.array!(@posts) do |post|
            json.extract! post, :id, :name, :post_url, :user_id
            json.url post_url(post, format: :json)
          end</code>
      </pre>
      <br><label class="text-center">views/api/v1/posts/show.json.jbuilder</label>
      <pre>
        <code class="language-ruby">
          json.extract! @post, :id, :name, :post_url, :user_id, :created_at, :updated_at</code>
      </pre>
       <br><label>You can use partials as well</label>
       <pre>
         <code class="language-ruby">
           json.array! @posts, partial: 'posts/post', as: :post</code>
       </pre>
    </div>
    <div class="step slide" data-x="17000" data-y="100">
      <br><label>To Customise your attributes you can use the following:</label>
      <pre>
        <code class="language-ruby">
        json.extract! @post, :id
        json.set! :first_name, @post.name
        json.extract! @post, :post_url, :user_id, :created_at, :updated_at</code>
      </pre>
      <br><label>Which will produce the following</label>
      <pre>
        <code class="language-javascript">
        {
          "id": 1,
          "first_name": "Sample",
          "post_url": "www.google.com",
          "user_id": 1,
          "created_at": "2014-05-22T14:07:20.235Z",
          "updated_at": "2014-05-22T14:07:20.235Z"
        }</code>
      </pre>
    </div>
    <div class="step slide" data-x="18000" data-y="100">
      <br><br><label class="text-center"><a href="http://railscasts.com/episodes/320-jbuilder">http://railscasts.com/episodes/320-jbuilder</a></label>
      <br><label class="text-center"><a href="https://github.com/rails/jbuilder">https://github.com/rails/jbuilder</a></label>
      <br><label class="text-center"><a href="http://railscasts.com/episodes/322-rabl?view=asciicast">http://railscasts.com/episodes/322-rabl</a></label>
      <br><label class="text-center"><a href="https://github.com/nesquena/rabl">https://github.com/nesquena/rabl</a></label>
    </div>
    <div class="step slide" data-x="21000" data-y="-100">
      <h1 class="center-content"><b>Active Model Serializers</b></h1>
    </div>
    <div class="step slide" data-x="21000" data-y="500">
      <br><label>ActiveModel::Serializers encapsulates the JSON serialization of objects.</label>
      <label><b>In short, serializers replace hash-driven development with object-oriented development.</b></label><br><br>
      <pre>
        <code class="language-ruby">
          gem "active_model_serializers"</code>
      </pre>
      <br>
      <pre>
        <code class="language-ruby">
          rails g resource comment content:text user:references post:references</code>
      </pre>
      <pre>
        <code class="language-ruby">
          rails g serializer comment</code>
      </pre>
      <br><label class="text-center">Will Generate <b>app/serializers/comment_serializer.rb</b></label>
    </div> 
    <div class="step slide" data-x="22000" data-y="500">
      <br><label>When we try to render out a model in a JSON format active model serializers automatically look for a serializer with the same name which is used to fetch data.</label>
      <br><label>So <b>render json: Post.find(params[:id])</b> will automatically look for a serialzer named PostSerializer</label>
      <pre><code class="language-ruby">
        class PostSerializer < ActiveModel::Serializer
          #attributes for post
        end
      </code></pre>
      <br><label>You can also specify a serializer while rendering json.</label>
      <pre>
        <code class="language-ruby">
          render json: @post, serializer: MyAwesomeSerializer</code>
      </pre>
    </div>
    <div class="step slide" data-x="23000" data-y="500">
      <h2 class="text-center"><b>Customizing the format</b></h2>
      <br><label>Since Active Model Serailizers follow an object oriented approach customising the output is a piece of cake!</label><br>
      <pre>
        <code class="language-ruby">
          class PostSerializer < ActiveModel::Serializer
            attributes :id, :name, :url, :custom_created_at
            
            def custom_time
              object.created_at.strftime('%H:%M')
            end
            
            def name
             obj.name.capitalize
            end
          end</code>
      </pre>
    </div>
    <div class="step slide" data-x="24000" data-y="500">
      <h2 class="text-center"><b>Customizing the root element</b></h2>
      <br><label>You can either disable the root element or specify one of your own. There are multiple ways to achieve this</label>
      <pre>
        <code class="language-ruby">
          render json: @posts, root: false</code>
      </pre>
      <pre>
        <code class="language-ruby">
          render json: @posts, root: "custom_posts"</code>
      </pre>
      <pre>
        <code class="language-ruby">
          class PostSerializer < ActiveModel::Serializer
            self.root = false
          end</code>
      </pre>
      <br><label class="text-center">initializers/active_model.rb</label>
      <pre>
        <code class="language-ruby">
          ActiveModel::Serializer.root = false</code>
      </pre>
    </div>
    <div class="step slide" data-x="25000" data-y="500">
      <h2><b>Handling Associations</b></h2>
      <br><label>Active Model Serializers works great with associations as well. You can specify has_many and belongs_to(which technically is has_one in this) in the serializer. This will automatically render the associated objects along with the current object.</label>
      <pre>
        <code class="language-ruby">
          class PostSerializer < ActiveModel::Serializer
            attributes :id, :name, :url
            has_many :comments
            has_one :user
          end</code>
      </pre>
      <br><label>And it works great with polymorphic relations too.</label>
      <pre>
        <code class="language-ruby">
          has_one :commentable, polymorphic: true</code>
      </pre>
    </div>
    <div class="step slide" data-x="26000" data-y="500">
      <h2>Consider the following example:</h2>
      <br><label>You have a Post model which has_many :comments, as: :commentable. The Comment model belongs_to :commentable, polymorphic: true</label><br>
      <pre>
        <code class="language-ruby">
          class PostSerializer < ActiveModel::Serializer
            attributes :id, :name, :url
            has_many :comments
          end
          </code>
      </pre><br>
      <pre>
        <code class="language-ruby">
          class CommentSerializer < ActiveModel::Serializer
            attributes :id, :content
            has_one :commentable, polymorphic: true
          end</code>
      </pre>
    </div>
    <div class="step slide" data-x="27000" data-y="500">
      <h2 class="text-center"><b>Embedding Ids</b></h2>
      <br><label>Sometimes you don't want to print out the associated objects as it rendering will be heavy. Instead you can embed only the ids of associated objects. Active Model Serializers has an option to embed only the ids.</label>
      <pre>
        <code class="language-ruby">
          class PostSerializer < ActiveModel::Serializer
            attributes :id, :name, :url
            embed :ids
            has_many :comments
          end
        </code>
      </pre>
      <br><label>If you want to include the object only once in your json you can also do that. This makes it easier to fetch content without repeating objects.</label>
      <pre>
        <code class="language-ruby">
          embed :ids, include: true</code>
      </pre>
    </div>
    <div class="step slide" data-x="28000" data-y="500">
      <h2 class="text-center"><b>Some Final Notes</b></h2>
      <br><label>Please note that serializers are always singular. Like PostSerializer and not Posts. Even if you are looping through an array of records it passes the serializer to each object and not the array itself.</label>
      <br><label class="text-center">Do checkout the Railscast here</label>
      <label class="text-center"><a href="http://railscasts.com/episodes/409-active-model-serializers">http://railscasts.com/episodes/409-active-model-serializers</a></label>
      <br><br><label>I might have missed to explain a few other features such as overriding the hash manually and about scope. Please checkout the repo for more: </label>
      <label class="text-center"><a href="https://github.com/rails-api/active_model_serializers">https://github.com/rails-api/active_model_serializers</a></label>
    </div>
    <div class="step slide" data-x="20000" data-y="1500">
      <h1 class="center-content"><b>CORS</b></h1>
    </div>
    <div class="step slide" data-x="21000" data-y="1500">
      <h2><b>What is it? Why should I use it?</b></h2>
      <br><label>CORS is Cross Origin Resource Sharing which is a W3C draft which specifies how the browser should communicate with the server when sharing resources across origins. Basically any request from other than the server is rejected with No 'Access-Control-Allow-Origin' header present error.</label>
      <br><label>CORS checks for custom HTTP headers so that it can verify the request.</label>
      <br><label>More on CORS<a href="http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/">http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/</a></label>
      <br><label>Now if we access our API from a client application then the server cannot validate the origin of the request. It throws an error that HTTP header could not be found. So how to handle it?</label>
    </div>
    <div class="step slide" data-x="22000" data-y="1500">
      <h2 class="text-center"><b>Rack CORS</b></h2>
      <br><label class="text-center"><a href="https://github.com/cyu/rack-cors">https://github.com/cyu/rack-cors</a></label><br>
      <pre>
        <code class="language-ruby">
          gem 'rack-cors', :require => 'rack/cors'</code>
      </pre>
      <br><label>It's really easy to configure the gem as well. You just have to provide the whitelist domains to allow access to your resources. If your API is to be consumed by third parties then we can whitelist all domains * and then write our own authentication.</label>
      <br><label>This Gem basically adds Rack::Cors to our Middleware that intercepts the requests and handles accordingly.</label>
    </div>
    <div class="step slide" data-x="22000" data-y="2500">
      <h1 class="center-content"><b>Securing your API</b></h1>
    </div>
  </div>
<script src="js/impress.js"></script>
<script type="text/javascript" src="js/prism.js"></script>
<script>impress().init();</script>
</body>
</html>